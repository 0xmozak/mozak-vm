on:
  workflow_call:
    secrets:
      READ_RUNNERS_TOKEN:
        required: true
    outputs:
      runner-label:
        value: ${{ jobs.check-runner.outputs.runner-label }}

jobs:
  check-runner:
    runs-on: ubuntu-latest
    outputs:
      runner-label: ${{ steps.set-runner.outputs.runner-label }}

    steps:
      - name: Set runner
        id: set-runner
        run: |
          curl_runners () {
            local -r url="$1"
            # Get all the runners
            runners=$(curl --silent --show-error \
              --header "Accept: application/vnd.github+json" \
              --header "Authorization: Bearer ${{ secrets.READ_RUNNERS_TOKEN }}" \
              --header "X-GitHub-Api-Version: 2022-11-28" \
              --location "${url}" || echo "")
            echo "${runners}"

            # If any self-hosted runners are online, use them.
            # Even if they are busy: our self-hosted runners are a lot faster than GitHub's runners.
            if echo "${runners}" | jq --exit-status '(.runners // [])[] | select(.status == "online" and .labels[] .name == "self-hosted")'; then
              # If we found an available self-hosted runner, then proceed to signal our desire to use self-hosted.
              echo "runner-label=self-hosted" | tee --append "${GITHUB_OUTPUT}"
              exit 0
            fi
          }

          # Try to find runners for this repo
          curl_runners "https://api.github.com/repos/${{ github.repository }}/actions/runners"

          # Try to find runners for this org
          curl_runners "https://api.github.com/orgs/${{ github.repository_owner }}/actions/runners"

          # We couldn't find any self-hosted runners, so fallback to GitHub runners
          echo "runner-label=ubuntu-latest" | tee --append "${GITHUB_OUTPUT}"
